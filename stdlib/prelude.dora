internal fun fatalError(msg: Str);
internal fun abort();
internal fun exit(status: int);

internal fun print(text: Str);
internal fun println(text: Str);
internal fun assert(val: bool);
internal fun argc() -> int;
internal fun argv(idx: int) -> Str;
internal fun forceCollect();

internal fun boolArrayWith(len: int, val: bool) -> BoolArray;
internal fun emptyBoolArray() -> BoolArray;

internal fun byteArrayWith(len: int, val: byte) -> ByteArray;
internal fun emptyByteArray() -> ByteArray;

internal fun intArrayWith(len: int, val: int) -> IntArray;
internal fun emptyIntArray() -> IntArray;

internal fun longArrayWith(len: int, val: long) -> LongArray;
internal fun emptyLongArray() -> LongArray;

internal fun floatArrayWith(len: int, val: float) -> FloatArray;
internal fun emptyFloatArray() -> FloatArray;

internal fun doubleArrayWith(len: int, val: double) -> DoubleArray;
internal fun emptyDoubleArray() -> DoubleArray;

internal class bool {
  internal fun toInt() -> int;
  internal fun toString() -> Str;

  internal fun equals(rhs: bool) -> bool;
  internal fun not() -> bool;
}

internal class byte {
  internal fun toInt() -> int;
  internal fun toLong() -> long;
  internal fun toString() -> Str;

  internal fun equals(rhs: byte) -> bool;
  internal fun compareTo(rhs: byte) -> int;
}

internal class int {
  internal fun toByte() -> byte;
  internal fun toLong() -> long;
  internal fun toString() -> Str;

  internal fun toFloat() -> float;
  internal fun toDouble() -> double;

  internal fun equals(rhs: int) -> bool;
  internal fun compareTo(rhs: int) -> int;

  internal fun plus(rhs: int) -> int;
  internal fun minus(rhs: int) -> int;
  internal fun times(rhs: int) -> int;
  internal fun div(rhs: int) -> int;
  internal fun mod(rhs: int) -> int;

  internal fun bitwiseOr(rhs: int) -> int;
  internal fun bitwiseAnd(rhs: int) -> int;
  internal fun bitwiseXor(rhs: int) -> int;

  internal fun shiftLeft(rhs: int) -> int;
  internal fun shiftRight(rhs: int) -> int;
  internal fun unsignedShiftRight(rhs: int) -> int;

  internal fun unaryPlus() -> int;
  internal fun unaryMinus() -> int;
  internal fun not() -> int;

  fun abs() -> int {
    if self >= 0 {
      return self;
    } else {
      return -self;
    }
  }
}

internal class long {
  internal fun toByte() -> byte;
  internal fun toInt() -> int;
  internal fun toString() -> Str;

  internal fun toFloat() -> float;
  internal fun toDouble() -> double;

  internal fun equals(rhs: long) -> bool;
  internal fun compareTo(rhs: long) -> int;

  internal fun plus(rhs: long) -> long;
  internal fun minus(rhs: long) -> long;
  internal fun times(rhs: long) -> long;
  internal fun div(rhs: long) -> long;
  internal fun mod(rhs: long) -> long;

  internal fun bitwiseOr(rhs: long) -> long;
  internal fun bitwiseAnd(rhs: long) -> long;
  internal fun bitwiseXor(rhs: long) -> long;

  internal fun shiftLeft(rhs: long) -> long;
  internal fun shiftRight(rhs: long) -> long;
  internal fun unsignedShiftRight(rhs: long) -> long;

  internal fun unaryPlus() -> long;
  internal fun unaryMinus() -> long;
  internal fun not() -> long;
}

internal class Str {
  internal fun equals(rhs: Str) -> bool;
  internal fun compareTo(rhs: Str) -> int;

  internal fun len() -> int;
  internal fun parseInt() -> int;
  internal fun plus(rhs: Str) -> Str;

  internal fun get(idx: int) -> byte;
  internal fun set(idx: int, val: int);
}

internal class float {
  internal fun toInt() -> int;
  internal fun toLong() -> long;
  internal fun toDouble() -> double;
  internal fun toString() -> Str;

  internal fun equals(rhs: float) -> bool;
  internal fun compareTo(rhs: float) -> int;

  internal fun plus(rhs: float) -> float;
  internal fun minus(rhs: float) -> float;
  internal fun times(rhs: float) -> float;
  internal fun div(rhs: float) -> float;

  internal fun unaryPlus() -> float;
  internal fun unaryMinus() -> float;

  internal fun isNan() -> bool;
  internal fun sqrt() -> float;
}

internal class double {
  internal fun toInt() -> int;
  internal fun toLong() -> long;
  internal fun toFloat() -> float;
  internal fun toString() -> Str;

  internal fun equals(rhs: double) -> bool;
  internal fun compareTo(rhs: double) -> int;

  internal fun plus(rhs: double) -> double;
  internal fun minus(rhs: double) -> double;
  internal fun times(rhs: double) -> double;
  internal fun div(rhs: double) -> double;

  internal fun unaryPlus() -> double;
  internal fun unaryMinus() -> double;

  internal fun isNan() -> bool;
  internal fun sqrt() -> double;
}

internal class BoolArray {
  internal fun len() -> int;
  internal fun get(idx: int) -> bool;
  internal fun set(idx: int, val: bool);
}

internal class ByteArray {
  internal fun len() -> int;
  internal fun get(idx: int) -> byte;
  internal fun set(idx: int, val: byte);
}

internal class IntArray {
  internal fun len() -> int;
  internal fun get(idx: int) -> int;
  internal fun set(idx: int, val: int);
}

internal class LongArray {
  internal fun len() -> int;
  internal fun get(idx: int) -> long;
  internal fun set(idx: int, val: long);
}

internal class FloatArray {
  internal fun len() -> int;
  internal fun get(idx: int) -> float;
  internal fun set(idx: int, val: float);
}

internal class DoubleArray {
  internal fun len() -> int;
  internal fun get(idx: int) -> double;
  internal fun set(idx: int, val: double);
}

class IntVec {
  var array: IntArray = nil;
  var length: int = 0;

  fun get(idx: int) -> int {
    if idx < 0 || idx >= self.length {
      fatalError("index out of bounds for vector");
    }

    return self.array[idx];
  }

  fun set(idx: int, val: int) {
    if idx < 0 || idx >= self.length {
      fatalError("index out of bounds for vector");
    }

    self.array[idx] = val;
  }

  fun push(val: int) {
    var newcap = self.capacity();

    if self.length == newcap {
      if newcap == 0 {
        newcap = 4;
      } else {
        newcap = newcap * 2;
      }

      let newarray = intArrayWith(newcap, 0);

      var i = 0;

      while i < self.length {
        newarray[i] = self.array[i];
        i = i + 1;
      }

      self.array = newarray;
    }

    self.array[self.length] = val;
    self.length = self.length + 1;
  }

  fun pop() -> int {
    if self.length == 0 {
      fatalError("no element left to pop");
    }

    let newlength = self.length - 1;
    let temp = self.array[newlength];
    self.length = newlength;

    return self.length;
  }

  fun trimToLen() {
    if self.length != self.capacity() {
      if self.length == 0 {
        self.array = nil;
      } else {
        let newarray = intArrayWith(self.length, 0);

        var i = 0;

        while i < self.length {
          newarray[i] = self.array[i];
          i = i + 1;
        }

        self.array = newarray;
      }
    }
  }

  fun len() -> int {
    return self.length;
  }

  fun capacity() -> int {
    if self.array === nil {
      return 0;
    } else {
      return self.array.len();
    }
  }
}

internal fun loadFunction(name: Str) -> long;
internal fun call0(fct: long) -> long;
internal fun call1(fct: long, arg0: long) -> long;
internal fun call2(fct: long, arg0: long, arg1: long) -> long;
internal fun call3(fct: long, arg0: long, arg1: long, arg2: long) -> long;

internal fun native_malloc(size: long) -> long;
internal fun native_free(address: long);
internal fun set_uint8(address: long, val: byte);

fun native_string(val: Str) -> long {
  var i = 0;
  let len = val.len();

  let ptr = native_malloc(len.toLong()+1L);

  while i < len {
    set_uint8(ptr+i.toLong(), val[i]);
    i = i + 1;
  }

  set_uint8(ptr+len.toLong(), 0B);

  return ptr;
}

fun getpid() -> int {
  let fct = loadFunction("getpid");
  return call0(fct).toInt();
}

fun getppid() -> int {
  let fct = loadFunction("getppid");
  return call0(fct).toInt();
}

class File(let name: Str) {
  fun delete() throws {
    let ptr = native_string(self.name);
    let fct = loadFunction("unlink");
    let res = call1(fct, ptr);
    native_free(ptr);

    if res != 0L {
      throw Exception("could not delete file");
    }
  }
}

class Exception(msg: Str)
