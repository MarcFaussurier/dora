abstract open class Regex {
    abstract fun debug() -> Str;
    abstract fun equals(rhs: Regex) -> bool;
}

// a | b
class Choice(let lhs: Regex, let rhs: Regex): Regex {
    override fun debug() -> Str {
        return "Choice(" + self.lhs.debug() + ", " + self.rhs.debug() + ")";
    }

    override fun equals(rhs: Regex) -> bool {
        if !(rhs is Choice) {
            return false;
        }

        let rhs = rhs as Choice;
        return self.lhs == rhs.lhs && self.rhs == rhs.rhs;
    }
}

// a b
class Sequence(let lhs: Regex, let rhs: Regex): Regex {
    override fun debug() -> Str {
        return "Seq(" + self.lhs.debug() + ", " + self.rhs.debug() + ")";
    }

    override fun equals(rhs: Regex) -> bool {
        if !(rhs is Sequence) {
            return false;
        }

        let rhs = rhs as Sequence;
        return self.lhs == rhs.lhs && self.rhs == rhs.rhs;
    }
}

// empty regex
class Blank: Regex {
    override fun debug() -> Str {
        return "Blank()";
    }

    override fun equals(rhs: Regex) -> bool {
        return rhs is Blank;
    }
}

// a*
class Repetition(let opnd: Regex): Regex {
    override fun debug() -> Str {
        return "Repetition(" + self.opnd.debug() + ")";
    }

    override fun equals(rhs: Regex) -> bool {
        if !(rhs is Repetition) {
            return false;
        }

        let rhs = rhs as Repetition;
        return self.opnd == rhs.opnd;
    }
}

// match char
class Primitive(let ch: char): Regex {
    override fun debug() -> Str {
        return self.ch.toString();
    }

    override fun equals(rhs: Regex) -> bool {
        if !(rhs is Primitive) {
            return false;
        }

        let rhs = rhs as Primitive;
        return self.ch == rhs.ch;
    }
}

class RegexParser(let pattern: String) {
    let it: StringCodePointIterator = pattern.codePoints();
    var look: char;
    var eof: bool = false;

    fun parse() throws -> Regex {
        self.consume();
        return try self.parseLevel0();
    }

    fun parseLevel0() throws -> Regex {
        let regex = try self.parseLevel1();

        if self.more() && self.peek() == '|' {
            try self.consumeChar('|');
            let rhs = try self.parseLevel0();
            return Choice(regex, rhs);
        } else {
            return regex;
        }
    }

    fun parseLevel1() throws -> Regex {
        var factor: Regex = Blank();

        while self.more() && self.peek() != ')' && self.peek() != '|' {
            let nextFactor = try self.parseLevel2();
            factor = Sequence(factor, nextFactor);
        }

        return factor;
    }

    fun parseLevel2() throws -> Regex {
        var regex = try self.parseLevel3();

        while self.more() && self.peek() == '*' {
            try self.consumeChar('*');
            regex = Repetition(regex);
        }

        return regex;
    }

    fun parseLevel3() throws -> Regex {
        let ch = self.peek();

        if ch == '(' {
            try self.consumeChar('(');
            let regex = try self.parseLevel0();
            try self.consumeChar(')');
            return regex;

        } else if ch == '\\' {
            try self.consumeChar('\\');
            let esc = self.consume();
            return Primitive(esc);

        } else {
            return Primitive(self.consume());

        }
    }

    fun consumeChar(ch: char) throws {
        if self.look != ch {
            throw RegexError("expected " + ch.toString() + " but got " + self.look.toString());
        }

        self.consume();
    }

    fun consume() -> char {
        let old = self.look;

        if self.eof {
            fatalError("consume() used although already at end of file");
        }

        if self.it.hasNext() {
            self.look = self.it.next();
        } else {
            self.eof = true;
        }

        return old;
    }

    fun more() -> bool {
        return !self.eof;
    }

    fun peek() -> char {
        if self.eof {
            fatalError("peek() used although already at end of file");
        }

        return self.look;
    }
}

class RegexError(let val: Str)

fun main() {
    let regex = try! RegexParser(String::from("a|b|c")).parse();
    println(regex.debug());
}