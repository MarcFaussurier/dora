class Graph {
  var name: Str;

  var start: Node;
  var end: Node;

  var nextNodeId: int;

  init(name: Str) {
    self.name = name;
    self.nextNodeId = 1;
  }

  fun getStart() -> Node { return self.start; }
  fun getEnd() -> Node { return self.end; }

  fun setStart(start: Node) { self.start = start; }
  fun setEnd(end: Node) { self.end = end; }

  fun newNode0(op: Operator) -> Node {
    let n = Node();
    n.id = self.nextNodeId;
    self.nextNodeId = self.nextNodeId + 1;
    n.op = op;

    return n;
  }

  fun newNode1(op: Operator, input1: Node) -> Node {
    let inputs = Array::<Node>(1);
    inputs[0] = input1;

    return self.newNodeX(op, inputs);
  }

  fun newNode2(op: Operator, input1: Node, input2: Node) -> Node {
    let inputs = Array::<Node>(2);
    inputs[0] = input1;
    inputs[1] = input2;

    return self.newNodeX(op, inputs);
  }

  fun newNode3(op: Operator, input1: Node, input2: Node, input3: Node) -> Node {
    let inputs = Array::<Node>(3);
    inputs[0] = input1;
    inputs[1] = input2;
    inputs[2] = input3;

    return self.newNodeX(op, inputs);
  }

  fun newNodeX(op: Operator, inputs: Array<Node>) -> Node {
    let n = Node();
    n.id = self.nextNodeId;
    self.nextNodeId = self.nextNodeId + 1;
    n.op = op;
    n.inputs = inputs;

    var i = 0;

    while i < inputs.len() {
      inputs[i].appendUsage(n);
      i = i + 1;
    }

    return n;
  }
}

class Node {
  var id: int;
  var op: Operator;
  var inputs: Array<Node>;

  var usages: Array<Node>;
  var usageCount: int;

  var ty: int;

  pub fun id() -> int {
    return self.id;
  }

  fun appendUsage(node: Node) {
    if self.usages === nil {
      self.usages = Array::<Node>(4);
      self.usages[0] = node;
      self.usageCount = 1;

    } else {
      var i = 0;

      while i < self.usageCount {
        if self.usages[i] === node {
          return;
        }

        i = i + 1;
      }

      if i >= self.usages.len() {
        let newusages = Array::<Node>(self.usages.len() * 2);
        arraycopy::<Node>(self.usages, 0, newusages, 0, self.usages.len());
        self.usages = newusages;
      }

      self.usages[i] = node;
      self.usageCount = self.usageCount + 1;
    }
  }

  fun removeUsage(node: Node) {
    if self.usages === nil {
      return;
    }

    var i = 0;

    while i < self.usageCount {
      let usage = self.usages[i];

      if usage === node {
        if i == self.usageCount-1 {
          self.usages[i] = nil;
          self.usageCount = self.usageCount - 1;

          return;
        }

        let replacement = self.usages[self.usageCount-1];
        self.usages[self.usageCount-1] = nil;
        self.usages[i] = replacement;
        self.usageCount = self.usageCount - 1;
      } else {
        i = i + 1;
      }
    }
  }

  fun replaceAllUsesWith(replace: Node) {
    var i = 0;

    while i < self.usageCount {
      self.usages[i].replaceAllUsesOf(self, replace);
      i = i + 1;
    }
  }

  fun replaceAllUsesOf(old: Node, replace: Node) {
    var i = 0;
    var replaced = false;

    while i < self.inputs.len() {
      if self.inputs[i] === old {
        self.inputs[i] = replace;
        replaced = true;
      }

      i = i + 1;
    }

    if replaced {
      old.removeUsage(self);
      replace.appendUsage(self);
    }
  }

  fun getValueInput(ind: int) -> Node {
    assert(ind < self.op.getValueInputCount());
    return self.inputs[ind];
  }

  fun getControlInput(ind: int) -> Node {
    assert(ind < self.op.getControlInputCount());
    return self.inputs[self.op.getValueInputCount() + ind];
  }
}

abstract open class Operator {
  abstract fun getValueInputCount() -> int;
  abstract fun getControlInputCount() -> int;
  abstract fun getValueOutputCount() -> int;
  abstract fun getControlOutputCount() -> int;
}

class Start(let params: int): Operator {
  override fun getValueInputCount() -> int { return 0; }
  override fun getControlInputCount() -> int { return 0; }
  override fun getValueOutputCount() -> int { return self.params; }
  override fun getControlOutputCount() -> int { return 1; }
}

class End(let input_count: int): Operator {
  override fun getValueInputCount() -> int { return 0; }
  override fun getControlInputCount() -> int { return self.input_count; }
  override fun getValueOutputCount() -> int { return 0; }
  override fun getControlOutputCount() -> int { return 0; }
}

class Merge(let input_count: int): Operator {
  override fun getValueInputCount() -> int { return 0; }
  override fun getControlInputCount() -> int { return self.input_count; }
  override fun getValueOutputCount() -> int { return 0; }
  override fun getControlOutputCount() -> int { return 1; }
}

class Branch: Operator {
  override fun getValueInputCount() -> int { return 1; }
  override fun getControlInputCount() -> int { return 1; }
  override fun getValueOutputCount() -> int { return 0; }
  override fun getControlOutputCount() -> int { return 2; }
}

class IfTrue: Operator {
  override fun getValueInputCount() -> int { return 0; }
  override fun getControlInputCount() -> int { return 1; }
  override fun getValueOutputCount() -> int { return 0; }
  override fun getControlOutputCount() -> int { return 1; }
}

class IfFalse: Operator {
  override fun getValueInputCount() -> int { return 0; }
  override fun getControlInputCount() -> int { return 1; }
  override fun getValueOutputCount() -> int { return 0; }
  override fun getControlOutputCount() -> int { return 1; }
}

class Return: Operator {
  override fun getValueInputCount() -> int { return 1; }
  override fun getControlInputCount() -> int { return 1; }
  override fun getValueOutputCount() -> int { return 0; }
  override fun getControlOutputCount() -> int { return 1; }
}

class Loop(let input_count: int): Operator {
  override fun getValueInputCount() -> int { return 0; }
  override fun getControlInputCount() -> int { return self.input_count; }
  override fun getValueOutputCount() -> int { return 0; }
  override fun getControlOutputCount() -> int { return 1; }
}

class Phi(let input_count: int): Operator {
  override fun getValueInputCount() -> int { return self.input_count; }
  override fun getControlInputCount() -> int { return 1; }
  override fun getValueOutputCount() -> int { return 1; }
  override fun getControlOutputCount() -> int { return 0; }
}

class Parameter(let name: Str): Operator {
  override fun getValueInputCount() -> int { return 1; }
  override fun getControlInputCount() -> int { return 0; }
  override fun getValueOutputCount() -> int { return 1; }
  override fun getControlOutputCount() -> int { return 0; }

  fun getName() -> Str { return self.name; }
}

class IntConst(let value: int): Operator {
  override fun getValueInputCount() -> int { return 0; }
  override fun getControlInputCount() -> int { return 0; }
  override fun getValueOutputCount() -> int { return 1; }
  override fun getControlOutputCount() -> int { return 0; }

  fun getValue() -> int { return self.value; }
}

class LongConst(let value: long): Operator {
  override fun getValueInputCount() -> int { return 0; }
  override fun getControlInputCount() -> int { return 0; }
  override fun getValueOutputCount() -> int { return 1; }
  override fun getControlOutputCount() -> int { return 0; }

  fun getValue() -> long { return self.value; }
}

class StrConst(let value: Str): Operator {
  override fun getValueInputCount() -> int { return 0; }
  override fun getControlInputCount() -> int { return 0; }
  override fun getValueOutputCount() -> int { return 1; }
  override fun getControlOutputCount() -> int { return 0; }

  fun getValue() -> Str { return self.value; }
}

class TestValueOperator(let input_count: int): Operator {
  override fun getValueInputCount() -> int { return self.input_count; }
  override fun getControlInputCount() -> int { return 0; }
  override fun getValueOutputCount() -> int { return 1; }
  override fun getControlOutputCount() -> int { return 0; }
}

fun main() {
  let g = Graph("foo");
}

const TYPE_UNTYPED: int = 0;
const TYPE_INT: int = 1;
const TYPE_LONG: int = 2;
const TYPE_FLOAT: int = 3;
const TYPE_DOUBLE: int = 4;
const TYPE_REF: int = 5;

fun testAppendUsage(t: Testing) {
  let g = Graph("test");

  let op = TestValueOperator(0);
  let n = g.newNode0(op);
  let u1 = g.newNode0(op);
  let u2 = g.newNode0(op);
  let u3 = g.newNode0(op);
  let u4 = g.newNode0(op);
  let u5 = g.newNode0(op);

  n.appendUsage(u1);
  assert(n.usageCount == 1);

  n.appendUsage(u2);
  assert(n.usageCount == 2);

  n.appendUsage(u1);
  assert(n.usageCount == 2);

  n.appendUsage(u2);
  assert(n.usageCount == 2);

  n.appendUsage(u3);
  assert(n.usageCount == 3);

  n.appendUsage(u4);
  assert(n.usageCount == 4);

  n.appendUsage(u5);
  assert(n.usageCount == 5);

  assert(n.usages[0] === u1);
  assert(n.usages[1] === u2);
  assert(n.usages[2] === u3);
  assert(n.usages[3] === u4);
  assert(n.usages[4] === u5);
}

fun testRemoveUsage(t: Testing) {
  let g = Graph("test");

  let op = TestValueOperator(0);
  let n = g.newNode0(op);
  let u1 = g.newNode0(op);
  let u2 = g.newNode0(op);

  n.appendUsage(u1);
  n.appendUsage(u2);
  assert(n.usageCount == 2);

  n.removeUsage(u1);
  assert(n.usageCount == 1);
  assert(n.usages[0] === u2);
  assert(n.usages[1] === nil);

  n.removeUsage(u2);
  assert(n.usageCount == 0);
  assert(n.usages[0] === nil);

  n.appendUsage(u1);
  n.appendUsage(u2);
  assert(n.usageCount == 2);
  n.removeUsage(u2);
  assert(n.usageCount == 1);
  assert(n.usages[0] === u1);
  assert(n.usages[1] === nil);
}

fun testReplaceAllUsesOf(t: Testing) {
  let g = Graph("test");

  let op = TestValueOperator(0);
  let i1 = g.newNode0(op);
  let i2 = g.newNode0(op);
  let i3 = g.newNode0(op);

  let n = g.newNode2(TestValueOperator(2), i1, i2);

  assert(n.inputs.len() == 2);
  assert(n.inputs[0] === i1);
  assert(n.inputs[1] === i2);

  n.replaceAllUsesOf(i1, i3);

  assert(n.inputs.len() == 2);
  assert(n.inputs[0] === i3);
  assert(n.inputs[1] === i2);

  let n = g.newNode2(TestValueOperator(2), i1, i1);

  n.replaceAllUsesOf(i1, i2);

  assert(n.inputs.len() == 2);
  assert(n.inputs[0] === i2);
  assert(n.inputs[1] === i2);
}

fun testReplaceAllUsesWith(t: Testing) {
  let g = Graph("test");

  let op = TestValueOperator(0);
  let i1 = g.newNode0(op);
  let i2 = g.newNode0(op);
  let i3 = g.newNode0(op);

  let n = g.newNode2(TestValueOperator(2), i1, i2);

  assert(i1.usageCount == 1);
  assert(i1.usages[0] === n);

  i1.replaceAllUsesWith(i3);

  assert(n.inputs.len() == 2);
  assert(n.inputs[0] === i3);
  assert(n.inputs[1] === i2);

  assert(i3.usageCount == 1);
  assert(i3.usages[0] === n);

  assert(i1.usageCount == 0);
  assert(i1.usages[0] === nil);
}

class NodeBitMap {
  var entries: Array<long> = nil;

  pub fun set(node: Node, value: bool) {
    self.setId(node.id(), value);
  }

  fun setId(id: int, value: bool) {
    if self.entries === nil && !value {
      return;
    }

    let index = id / 64;

    if self.entries !== nil && index < self.entries.len() {
      self.setBit(index, id % 64, value);

    } else if value {
      let new = Array::<long>(int::min(4, index+1));

      if self.entries !== nil {
        arraycopy::<long>(self.entries, 0, new, 0, self.entries.len());
      }

      self.setBit(index, id, value);
    }
  }

  fun setBit(index: int, bit: int, value: bool) {
    assert(index < self.entries.len());
    let old = self.entries[index];

    if value {
      self.entries[index] = old | (1L << bit.toLong());
    } else {
      self.entries[index] = old & !(1L << bit.toLong());
    }
  }

  pub fun get(node: Node) -> bool {
    return self.getId(node.id());
  }

  fun getId(id: int) -> bool {
    if self.entries === nil {
      return false;
    }

    let index = id / 64;

    if index < self.entries.len() {
      let value = self.entries[index];
      let bit = id % 64;

      if value & (1L << bit.toLong()) != 0L {
        return true;
      } else {
        return false;
      }
    }

    return false;
  }
}

fun testNodeBitMap() {
  let bm = NodeBitMap();

  bm.setId(0, false);
  assert(bm.entries === nil);

  bm.setId(64, false);
  assert(bm.entries === nil);

  bm.setId(2, true);
  assert(bm.entries.len() == 4);
  assert(bm.entries[0] == 4L);

  bm.setId(64, true);
  assert(bm.entries.len() == 4);
  assert(bm.entries[0] == 4L);
  assert(bm.entries[1] == 1L);

  assert(bm.getId(1000) == false);
  assert(bm.getId(2) == true);
  assert(bm.getId(3) == false);
  assert(bm.getId(64) == true);
  assert(bm.getId(65) == false);
}