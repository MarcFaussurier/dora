class Graph {
  var name: Str;

  var start: Node;
  var end: Node;

  var nextNodeId: int;

  init(name: Str) {
    self.name = name;
  }

  fun getStart() -> Node { return self.start; }
  fun getEnd() -> Node { return self.end; }

  fun buildStart(params: int) -> Node {
    return self.newNode0(Start(params));
  }

  fun buildEnd(inputs: int) -> Node {
    return self.newNode0(End(inputs));
  }

  fun buildIntConst(val: int) -> Node {
    return self.newNode0(IntConst(val));
  }

  fun buildLongConst(val: long) -> Node {
    return self.newNode0(LongConst(val));
  }

  fun newNode0(op: Operator) -> Node {
    let n = Node();
    n.id = self.nextNodeId;
    self.nextNodeId = self.nextNodeId + 1;
    n.op = op;

    return n;
  }

  fun newNode1(op: Operator, input1: Node) -> Node {
    let n = Node();
    n.id = self.nextNodeId;
    self.nextNodeId = self.nextNodeId + 1;
    n.op = op;

    let array = Array::<Node>(1);
    array[0] = input1;
    n.inputs = array;

    return n;
  }

  fun newNode2(op: Operator, input1: Node, input2: Node) -> Node {
    let n = Node();
    n.id = self.nextNodeId;
    self.nextNodeId = self.nextNodeId + 1;
    n.op = op;

    let array = Array::<Node>(2);
    array[0] = input1;
    array[1] = input2;
    n.inputs = array;

    return n;
  }

  fun newNodeX(op: Operator, inputs: Array<Node>) -> Node {
    let n = Node();
    n.id = self.nextNodeId;
    self.nextNodeId = self.nextNodeId + 1;
    n.op = op;
    n.inputs = inputs;

    return n;
  }
}

class Node {
  var id: int;
  var op: Operator;
  var inputs: Array<Node>;

  var ty: int;

  fun getValueInput(ind: int) -> Node {
    assert(ind < self.op.getValueInputCount());
    return self.inputs[ind];
  }

  fun getControlInput(ind: int) -> Node {
    assert(ind < self.op.getControlInputCount());
    return self.inputs[self.op.getValueInputCount() + ind];
  }
}

abstract open class Operator {
  abstract fun getValueInputCount() -> int;
  abstract fun getControlInputCount() -> int;
  abstract fun getValueOutputCount() -> int;
  abstract fun getControlOutputCount() -> int;
}

class Start(let params: int): Operator {
  override fun getValueInputCount() -> int { return 0; }
  override fun getControlInputCount() -> int { return 0; }
  override fun getValueOutputCount() -> int { return self.params; }
  override fun getControlOutputCount() -> int { return 1; }
}

class End(let input_count: int): Operator {
  override fun getValueInputCount() -> int { return 0; }
  override fun getControlInputCount() -> int { return self.input_count; }
  override fun getValueOutputCount() -> int { return 0; }
  override fun getControlOutputCount() -> int { return 0; }
}

class Merge(let input_count: int): Operator {
  override fun getValueInputCount() -> int { return 0; }
  override fun getControlInputCount() -> int { return self.input_count; }
  override fun getValueOutputCount() -> int { return 0; }
  override fun getControlOutputCount() -> int { return 1; }
}

class Branch: Operator {
  override fun getValueInputCount() -> int { return 1; }
  override fun getControlInputCount() -> int { return 1; }
  override fun getValueOutputCount() -> int { return 0; }
  override fun getControlOutputCount() -> int { return 2; } 
}

class IfTrue: Operator {
  override fun getValueInputCount() -> int { return 0; }
  override fun getControlInputCount() -> int { return 1; }
  override fun getValueOutputCount() -> int { return 0; }
  override fun getControlOutputCount() -> int { return 1; } 
}

class IfFalse: Operator {
  override fun getValueInputCount() -> int { return 0; }
  override fun getControlInputCount() -> int { return 1; }
  override fun getValueOutputCount() -> int { return 0; }
  override fun getControlOutputCount() -> int { return 1; } 
}

class Return: Operator {
  override fun getValueInputCount() -> int { return 1; }
  override fun getControlInputCount() -> int { return 1; }
  override fun getValueOutputCount() -> int { return 0; }
  override fun getControlOutputCount() -> int { return 1; } 
}

class Loop(let input_count: int): Operator {
  override fun getValueInputCount() -> int { return 0; }
  override fun getControlInputCount() -> int { return self.input_count; }
  override fun getValueOutputCount() -> int { return 0; }
  override fun getControlOutputCount() -> int { return 1; } 
}

class Phi(let input_count: int): Operator {
  override fun getValueInputCount() -> int { return self.input_count; }
  override fun getControlInputCount() -> int { return 1; }
  override fun getValueOutputCount() -> int { return 1; }
  override fun getControlOutputCount() -> int { return 0; } 
}

class Parameter(let name: Str): Operator {
  override fun getValueInputCount() -> int { return 1; }
  override fun getControlInputCount() -> int { return 0; }
  override fun getValueOutputCount() -> int { return 1; }
  override fun getControlOutputCount() -> int { return 0; }

  fun getName() -> Str { return self.name; }
}

class IntConst(let value: int): Operator {
  override fun getValueInputCount() -> int { return 0; }
  override fun getControlInputCount() -> int { return 0; }
  override fun getValueOutputCount() -> int { return 1; }
  override fun getControlOutputCount() -> int { return 0; }

  fun getValue() -> int { return self.value; }
}

class LongConst(let value: long): Operator {
  override fun getValueInputCount() -> int { return 0; }
  override fun getControlInputCount() -> int { return 0; }
  override fun getValueOutputCount() -> int { return 1; }
  override fun getControlOutputCount() -> int { return 0; }

  fun getValue() -> long { return self.value; }
}

fun main() {
  let g = Graph("foo");
}

const TYPE_UNTYPED: int = 0;
const TYPE_INT: int = 1;
const TYPE_LONG: int = 2;
const TYPE_FLOAT: int = 3;
const TYPE_DOUBLE: int = 4;
const TYPE_REF: int = 5;